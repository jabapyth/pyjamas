= Merging Javascript into Python Pyjamas applications =

Pyjamas is compiler technology: it converts python source code into
javascript source code.  In a way, pyjs.py - the compiler - is very
much like gcc, the Gnu C Compiler.  gcc turns perfectly good (or bad)
c code into a human-unreadable mess, using an intermediate step:
assembler.  The Pyjamas compiler effectively turns python source
code into "assembly-like" javascript.  Another way to put this is
that it is <i>pure coincidence</i> (it's not, really!) that the
"assembly output" of pyjamas happens to be reasonably-human-readable
javascript.

There is quite a lot of javascript functionality which needs to be accessible
by Pyjamas applications, in order for Pyjamas to be useful (especially in
Web Browsers), and so the design of the Pyjamas compiler has had to include
a way to understand javascript libraries, and to be able to include javascript
code fragments into the output, unmodified.

Being able to insert javascript fragments is conceptually identical to the gcc
method of doing "inline assembler".  in gcc, you do horrible things like this:
{{
    int a=10, b;
    asm ("movl %1, %%eax; 
        movl %%eax, %0;"
        :"=r"(b)        /* output */
        :"r"(a)         /* input */
        :"%eax"         /* clobbered register */
        );       
}}
And, in Pyjamas, it's not that different:
{{
def foo(b): # this is python-land
    a = 10; # this is still python-land
    JS("""
        b = a; /* this is javascript-land */
    """)
}}

So, crucially, this chapter will cover what it is that needs careful attention,
when wrapping a javascript library in Python code; how Python functions 
should be called from inside wrapped javascript (and the problems associated
with doing that); and the importance of double-checking the compiled output
against the original Python code, to make sure that everything's reasonable.

Crucially, at this point, it must be said that this is not for the
faint-hearted: assembly-style programming never is.  Not only is it necessary
to know <i>two</i> programming languages; not only is it necessary to know
how the compiler interfaces the two together, but also, it's necessary to
work at "second hand" with one of the languages, when debugging the application!
That having been said, it <i>is</i> quite straightforward.

= Simple Rectangle Test Class =

The purpose of this exercise is to show, using as small a useful javascript
library as possible, how to wrap Javascript with Pyjamas.  Start by saving
the following javascript code as a file called jsrecttest.js:
{{
function rectobj() {
}

function rect_init(x, y) {
    this.x = x;
    this.y = y;
}

function rect_area() {
    return this.x * this.y;
}

function rect_add(rect) {
    this.x += rect.x;
    this.y += rect.y;
}

rectobj.prototype.area = rect_area;
rectobj.prototype.add = rect_add;
rectobj.prototype.init = rect_init;
}}

If javascript is unfamiliar, then <i>right now</i> please take a minute to
look up prototyping, and how javascript objects work.  An object instance
can be created in javascript, like this:
{{
    var obj = new rectobj();
}}

It's quite obtuse, but easy to follow: the function <tt>rectobj()</tt> is being
called, but the qualifier "new" tells javascript to actually make an object,
and thus, any occurrences of the word "this" can be used - just like "self"
in python and "this" in c++ - to member variables, functions and objects.
So, the function <tt>rect_init()</tt> adds two variables to a <tt>rectobj</tt>;
<tt>rect_area</tt> can return those two variables, multiplied together.

Crucially, however, the last three lines are what makes javascript incredibly
powerful.  Notice the use of "prototype" - that's telling the javascript
engine that all future declarations of "new" rectobjs <em>must</em>
have those three functions added to them.

Exactly the same thing can be done in Python - it's just that it's not
good sane practice to modify Python classes on-the-fly, as anyone reading
the Python source code is going to get a real headache, wondering where
on earth the extra functions are coming from.  However, javascript is a
pure prototyping language; there <i>are</i> no "classes"; there is only
prototype.  Given that there isn't any choice in the matter (javascript
programmers being used to getting headaches), everybody's happy.

{{-info
It's worth noting that the reason why Python and Javascript work so well
together is because of the dynamic run-time similarity - this ability to
create classes in Python, by modifying the object, and adding functions
at runtime, being so similar to javascript's prototype capabilities.
By contrast, The PyPy team (PyPy is an E.U-funded compiler project)
are having a very difficult time with the Java Bytecode back-end,
because Java, as a language, is simply not equipped with such
dynamism as Python and Javascript.  Consequently, Java Bytecode -
and the JVM it runs on - does not react favourably to such maltreatment.
}}

Whilst it would be unkind to create an <i>exact</i> replica of what's going
on with <tt>jsrecttest.js</tt>, an "equivalent" program in Python is here,
for illustrative purposes only:
{{
class rectobj:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def area(self):
        return self.x * self.y
    def add(self, rect):
        self.x += rect.x
        self.y += rect.y
}}
The reason why this isn't exactly the same is because, in <tt>jsrecttest.js</tt>
the javascript "class" (not that there is such a concept of classes in 
javascript) is being created dynamically.  So it's more like this:
{{
class rectobj:
    pass
def rect_area(self):
    return self.x * self.y
def rect_add(self, rect):
    self.x += rect.x
    self.y += rect.y
def rect_init(self, x, y):
    self.x = x
    self.y = y
rectobj.__init__ = rect_init
rectobj.add = rect_add
rectobj.area = rect_area

x = rectobj(5, 2)
y = rectobj(2, 7)
print x.area()
x.add(y)
print x.area()
}}
Python purists should either be screaming or quaking in their boots at the
incorrectness of this approach.  The particularly well-informed ones will
likely scream loudest about the lack of decorators.


