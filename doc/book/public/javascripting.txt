= Merging Javascript into Python Pyjamas applications =

Pyjamas is compiler technology: it converts python source code into
javascript source code.  In a way, pyjs.py - the compiler - is very
much like gcc, the Gnu C Compiler.  gcc turns perfectly good (or bad)
c code into a human-unreadable mess, using an intermediate step:
assembler.  The Pyjamas compiler effectively turns python source
code into "assembly-like" javascript.  Another way to put this is
that it is <i>pure coincidence</i> (it's not, really!) that the
"assembly output" of pyjamas happens to be reasonably-human-readable
javascript.

There is quite a lot of javascript functionality which needs to be accessible
by Pyjamas applications, in order for Pyjamas to be useful (especially in
Web Browsers), and so the design of the Pyjamas compiler has had to include
a way to understand javascript libraries, and to be able to include javascript
code fragments into the output, unmodified.

Being able to insert javascript fragments is conceptually identical to the gcc
method of doing "inline assembler".  in gcc, you do horrible things like this:
{{
    int a=10, b;
    asm ("movl %1, %%eax; 
        movl %%eax, %0;"
        :"=r"(b)        /* output */
        :"r"(a)         /* input */
        :"%eax"         /* clobbered register */
        );       
}}
And, in Pyjamas, it's not that different:
{{
def foo(b): # this is python-land
    a = 10; # this is still python-land
    JS("""
        b = a; /* this is javascript-land */
    """)
}}

So, crucially, this chapter will cover what it is that needs careful attention,
when wrapping a javascript library in Python code; how Python functions 
should be called from inside wrapped javascript (and the problems associated
with doing that); and the importance of double-checking the compiled output
against the original Python code, to make sure that everything's reasonable.

Crucially, at this point, it must be said that this is not for the
faint-hearted: assembly-style programming never is.  Not only is it necessary
to know <i>two</i> programming languages; not only is it necessary to know
how the compiler interfaces the two together, but also, it's necessary to
work at "second hand" with one of the languages, when debugging the application!
That having been said, it <i>is</i> quite straightforward.

= Simple Rectangle Test Class =

The purpose of this exercise is to show, using as small a useful javascript
library as possible, how to wrap Javascript with Pyjamas.  Start by saving
the following javascript code as a file called jsrecttest.js:
{{
function rectobj() {
}

function rect_init(x, y) {
    this.x = x;
    this.y = y;
}

function rect_area() {
    return this.x * this.y;
}

function rect_add(rect) {
    this.x += rect.x;
    this.y += rect.y;
}

rectobj.prototype.area = rect_area;
rectobj.prototype.add = rect_add;
rectobj.prototype.init = rect_init;
}}

If javascript is unfamiliar, then <i>right now</i> please take a minute to
look up prototyping, and how javascript objects work.  An object instance
can be created in javascript, like this:
{{
    var obj = new rectobj();
}}

It's quite obtuse, but easy to follow: the function <tt>rectobj()</tt> is being
called, but the qualifier "new" tells javascript to actually make an object,
and thus, any occurrences of the word "this" can be used - just like "self"
in python and "this" in c++ - to member variables, functions and objects.
So, the function <tt>rect_init()</tt> adds two variables to a <tt>rectobj</tt>;
<tt>rect_area</tt> can return those two variables, multiplied together.

Crucially, however, the last three lines are what makes javascript incredibly
powerful.  Notice the use of "prototype" - that's telling the javascript
engine that all future declarations of "new" rectobjs <em>must</em>
have those three functions added to them.

Exactly the same thing can be done in Python - it's just that it's not
good sane practice to modify Python classes on-the-fly, as anyone reading
the Python source code is going to get a real headache, wondering where
on earth the extra functions are coming from.  However, javascript is a
pure prototyping language; there <i>are</i> no "classes"; there is only
prototype.  Given that there isn't any choice in the matter (javascript
programmers being used to getting headaches), everybody's happy.

{{-info
It's worth noting that the reason why Python and Javascript work so well
together is because of the dynamic run-time similarity - this ability to
create classes in Python, by modifying the object, and adding functions
at runtime, being so similar to javascript's prototype capabilities.
By contrast, The PyPy team (PyPy is an E.U-funded compiler project)
are having a very difficult time with the Java Bytecode back-end,
because Java, as a language, is simply not equipped with such
dynamism as Python and Javascript.  Consequently, Java Bytecode -
and the JVM it runs on - does not react favourably to such maltreatment.
}}

Whilst it would be unkind to create an <i>exact</i> replica of what's going
on with <tt>jsrecttest.js</tt>, an "equivalent" program in Python is here,
for illustrative purposes only:
{{
class rectobj:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def area(self):
        return self.x * self.y
    def add(self, rect):
        self.x += rect.x
        self.y += rect.y
}}
The reason why this isn't exactly the same is because, in <tt>jsrecttest.js</tt>
the javascript "class" (not that there is such a concept of classes in 
javascript) is being created dynamically.  So it's more like this:
{{
class rectobj:
    pass
def rect_area(self):
    return self.x * self.y
def rect_add(self, rect):
    self.x += rect.x
    self.y += rect.y
def rect_init(self, x, y):
    self.x = x
    self.y = y
rectobj.__init__ = rect_init
rectobj.add = rect_add
rectobj.area = rect_area
}}
Python purists should either be screaming or quaking in their boots at the
incorrectness of this approach.  The particularly well-informed ones will
likely scream loudest about the lack of decorators.  All of which is
irrelevant, because only the most insane or the most confident of Python
programmers would dare do anything like this.  But - it's here for
illustrative purposes.

Moving swiftly on, create a file, TestRect.py, with the following contents:
{{
import jsrecttest.js # YUK!!!

class Rect: 
    def __init__(self, x, y):
        JS("""
           this.rect = new rectobj();
           this.rect.init(x, y);
           """)

    def add(self, r):
        JS("""
            this.rect.add(r.rect);
           """)
    def area(self):
        JS("""
            return this.rect.area();
           """)

    def get_x(self):
        JS("""
            return this.rect.x;
            """)

    def get_y(self):
        JS("""
            return this.rect.y;
            """)
}}
Straight away, notice two critical things: firstly, importing jsrecttest.js
with an extension ".js" is <i>definitely</i> not standard python - but then
again, the whole concept of compiling python into javascript throws spanners
in the works.  Secondly: in this strange-looking Python class, whilst every
function uses "self", the javascript snippets use "this".
{{-info
"self" in python is just a convention.  If it feels more comfortable,
substitute all occurences of the word "self" - consistently - in a python
class member function - and the feeling of panic and unease should subside,
only to be replaced by a different form of unease at breaking a python
convention: the disappearance of the word "self" from the python code...
}}

The inclusion of jsrecttest.js as if it was a python module is
<i>definitely</i> non-pythonic, but due to the way that pyjamas code
is generated, and to ensure that there are no surprises, there really
isn't much choice.  Browsers have a habit of executing code when it is
loaded - but <i>only</i> when the code is included from the initial
web page.  If javascript is used, to modify the URL of the browser page,
to load up a second HTML page, things start to go horribly wrong.
So, the only way to guarantee that no limitations are imposed is to
actually include the script <i>wholesale</i> and <i>inline</i>, in the
Pyjamas compiled output!

Examining the class <tt>Rect</tt>, it can be seen that the initialisation
appears - somehow - to magically go into javascript-land and create a
<tt>rectobj()</tt> as a member variable, and that the rectobj instance
gets initialised with the same x and y parameters that the Python
<tt>Rect</tt> class gets initialised with!  It's the same story, throughout
all of the functions, and at this point, it's a very very good idea to
run the pyjs.py compiler, to find out what's going on.  Run the following
command (assuming that you saved the files in a subdirectory of examples,
or are executing the command from the pyjamas/examples/jsobject directory):
{{
    python ../../pyjs/pyjs.py TestRect.py
}}

The output from pyjs.py is printed on-screen, and, an abbreviated version
is shown, here:
{{
function __Rect() {
}
function Rect(x, y) {
    var instance = new __Rect();
    if(instance.__init__) instance.__init__.apply(instance, arguments);
    return instance;
}

function __Rect_initialize() {
    if(__Rect.__was_initialized__) return;
    __Rect.__was_initialized__ = true;
    pyjs_extend(__Rect, __pyjslib_Object);
    __Rect.prototype.__class__.__new__ = Rect;
    __Rect.prototype.__init__ = function(x, y) {

           this.rect = new rectobj();
           this.rect.init(x, y);
           
    };
    __Rect.prototype.get_x = function() {

            return this.rect.x;
            
    };

    /* ...
       functions cut, for clarity and brevity, are area, get_y and add.
       as well as a boat-load of non-intuitive crud.
       ...
     */
}
__Rect_initialize();
}}
To explain the morass of extra code: it's to create some semblance and
imitation of pythonic classes, in a language which doesn't have classes.
Note in particular the use of the function pyjs_extend, which emulates
class inheritance; the technique is prevalent in javascript libraries,
to "extend" the functionality of an object by copying its methods into
the child "class".

The thing that needs particular attention is this line:
{{
    __Rect.prototype.__init__ = function(x, y) {
}}
This line sets up "class" initialiser function, called __init__, which
has two parameters, x and y.  Just like in c++, the concept of "this"
is implicit in javascript: you always unavoidably get one, and so it
need not be passed around as a parameter.  Note that the <i>contents</i>
of the __init__ function are - literally verbatim - what was placed
inside the JS(""" """) inlining wrapper.

Regarding the remaining functions, and to illustrate in a clearer manner
the relationship between Python and its resultant javascript output when
compiled, change the <tt>get_x()</tt> function, as follows:
{{
    def get_x(self):
        return self.rect.x
}}
Re-run pyjs,py and look for the following lines, in the output:
{{
    __Rect.prototype.get_x = function() {
    return this.rect.x;
    };
}}
That's... that's the same, isn't it?  Yes and no: there's more
white-space in the previous example, and the reason for <i>that</i>
is because, inside the original JS(""" return this.rect.x; """) block
there was... a lot of white-space.  Go back to the previous code,
and either remove <i>all</i> white-space, add in javascript-style
comments, or remove the indentation, and re-run pyjs.py.

In other words, what's happened is that the auto-generated code <i>happens</i>
to be identical to the code that we inlined.  pyjs.py <i>happens</i> to
"understand" how to turn python "self" into javascript "this", and the
syntax of javascript <i>happens</i> to be similar to python, in this simple
example.

