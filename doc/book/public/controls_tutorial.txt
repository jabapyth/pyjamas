= Writing a Widget for Pyjamas =

An important part of a widget toolkit is being able to write custom
widgets.  In many widget sets, developers are confronted immediately with
a quite complex set of unusual-looking functions - paint, draw,
refresh and other manipulations.  The reason for this complexity is
because the fundamental underlying design of Desktop widget set frameworks
is invariably too simplistic.  Changes in width or height of a single
widget can have a knock-on effect that dramatically alters the layout
of the entire application.  Rather than attempting to solve this really
quite difficult problem, Desktop widgets simply avoid it entirely, and
impose on the developer to sort out the mess for themselves.

The only technology that has tackled the issue of complex layouts,
with any degree of success, is Web Browsers.  Web browsers simply
<i>have</i> to tackle layouts properly, due to the sheer user-driven
diversity. Consequently, Pyjamas and Pyjamas-Desktop, both being based
on web technology, benefit from the underlying layout issues having
been made a lot easier.

Both Pyjamas and Pyjamas-Desktop manipulate the DOM model - an
HTML page - as if it was an XML document.  Better than that: unlike
with manipulating an HTML page, it's not necessary to get involved with
Javascript - unless desired.  Pyjamas provides a module which
makes the job of controlling the underlying DOM model that much easier,
and this chapter shows step-by-step how to go about creating a
custom widget.

Missing from the HTML specification, but present in Adobe Flash,
is things like sliders and dials.  Many Desktop widget sets have
control widgets, so it makes a lot of sense to create one.  So this
chapter starts with a simple Vertical scroller which receives
"mouse click" to change the position.

= Vertical Slider =

Start off by importing the DOM model and, because the slider will
receive mouse (and later keyboard) events, it is based on FocusWidget.
FocusWidget has the means to add keyboard and event listeners, set
a "tab order" index, and to set and clear focus.  Create a file
called Controls.py, starting off with the following lines:
{{
from pyjamas import DOM
from pyjamas.ui import FocusWidget
}
The class will be derived from FocusWidget.  Width and height parameters
will not be added to the constructor, because Pyjamas Widgets are based on
HTML principles: DOM models.  So, a CSS "Class" is added, with
setStyleName(), and the width and/or height set as desired in the
CSS stylesheet, or the functions setWidth() and setHeight() must be used.
It <i>is</i> however necessary to pass in the slider's
minimum, maximum and default values.
{{-info
This is an important point to emphasise: widgets should not impose "look"
onto users - that should, ideally, be defined through CSS. A Widget Class
API should be about "function" rather than "look".  So, the constructor
for the widget has minimum, maximum and default values, not width, height
or colour.
}}
Add the following lines to the newly-created Controls.py:
{{
class VerticalDemoSlider(FocusWidget):

    def __init__(self, min_value, max_value, start_value=None):

        element = DOM.createDiv()
        FocusWidget.__init__(self, element)

        self.min_value = min_value
        self.max_value = max_value
        if start_value is None:
            start_value = min_value
        self.value = start_value
        self.valuechange_listeners = []
}}
Here also is the first actual bit of underlying HTML / DOM model
showing through: the widget is based on a "div" tag, hence we
call DOM.createDiv() and set that as the FocusWidget's element.
Immediately, therefore, it is clear that the Pyjamas Widgets
are effectively "guardian" classes that look after and
manipulate bits of the underlying DOM model, making the whole
process of creating and maintaining your application just that
little bit easier to understand.

Next, it is necessary to make the slider "handle" and to make it
possible for the handle to move freely.  In other words, it is
necessary to be able to set the coordinates, exactly, of the
slider "handle".  There is a Pyjamas ui widget which has exactly
this functionality, already: AbsolutePanel. 
Take a look at pyjamas/ui.py and search for "class AbsolutePanel".
Examining what AbsolutePanel.__init__() does, it can be seen that
by setting its "div" container tag to be position "relative",
child elements can be positioned accurately.  Also, a second hard-coded
"div" will be added, to represent the actual slider handle:
{{
        DOM.setStyleAttribute(element, "position", "relative")
        DOM.setStyleAttribute(element, "overflow", "hidden") 

        self.handle = DOM.createDiv()
        DOM.appendChild(element, self.handle)
}}
Note that the second "handle" div is appended to the container "div".
As this is just a demonstration, we're going to hand-code the
slider handle with some attributes, making it 10 pixels high, a border
of 1 pixel, fixing it to be the same width as the Widget, and making it
a grey colour.
{{-info
A much better way to do this would be to set a CSS stylesheet where
users could over-ride all these settings.  the "handle" element
would have a CSS style added to it, using addStyleName.
}}
Note also that DOM.setAttribute() is not used to set the border,
width and height.  HTML specifications need to be consulted,
here: observe that "border" is a CSS attribute reserved for DOM
components such as "table".  So, if DOM.setAttribute() is called
on a "div" tag, it silently fails to do anything, in the browser.
If the Javascript Console is examined, luck <i>might</i> have it
that there is a warning.
{{-info
If the same thing is tried under Pyjamas-Desktop, a much more useful
run-time error will occur, as the attributes and the CSS style attributes
of an element are directly accessed as static variables, in entirely
different structures. If the variables don't exist, Python can do nothing
but complain.
}}
The upshot is: pay attention to the underlying DOM model, and remember
to simultaneously develop your app using <i>both</i> Pyjamas <i>and</i>
Pyjamas-Desktop, to save yourself a great deal of time.  If you want 
to set a border on a "div" tag, you must set it as a CSS Style attribute,
<i>not</a> an attribute (with setAttribute):
{{
    DOM.setStyleAttribute(self.handle, "border", "1px")
    DOM.setStyleAttribute(self.handle, "width", "100%")
    DOM.setStyleAttribute(self.handle, "height", "10px")
    DOM.setStyleAttribute(self.handle, "backgroundColor", "#808080")
}}
These lines make the slider "handle" have a border of 1 pixel; set the
handle width to always be the same as its container; set its height to
10 pixels, and set its colour to a nice boring shade of grey.

== Testing ==

With these basic beginnings, it's enough to test out, to see if it's
working.  If that was wanted was a little grey box in a widget, the
task would be complete.  However, it's good practice to confirm what's
already working, before proceeding.  In the same directory that the
Controls.py module has been saved, create an HTML Loader file,
ControlDemo.html, with the following contents:
{{
<html>
    <head>
        <meta name="pygwt:module" content="ControlDemo">
        <title>Hello</title>
    </head>
    <body bgcolor="white">
        <script language="javascript" src="pygwt.js"></script>
    </body>
</html>
}}
Next, create a file, ControlDemo.py, again in the same directory,
with the following contents:
{{
""" testing our demo slider
"""
from pyjamas.ui import RootPanel
from Controls import VerticalDemoSlider

class ControlDemo:
    def onModuleLoad(self):
        b = VerticalDemoSlider(0, 100)
        RootPanel().add(b)
        b.setWidth("20px")
        b.setHeight("100px")
}}
Note that the Demo slider has been imported from Controls.py, which is
why it was necessary to place ControlDemo.py in the same directory.
Also, note that the width and height are set, hard-coded, to 20 by 100
pixels.  b.setStyleName("demoslider") could have been used, instead,
but that would require the creation of a CSS stylesheet along with
referencing it in ControlDemo.html.

One thing that's great about Pyjamas: these eight lines are enough code to
do exactly what is desired, with clear and consise purpose: create a slider,
add it to the root panel, set its width to 20 pixels and the height to 100.
It really couldn't get any easier.  Compile the example with the following
command:
{{
    python ../../builder/build.py ControlDemo.py
}}
Open output/ControlDemo.html in a web browser, and it should
result in a delightful 20x10 grey box being displayed, which is
very exciting.  Next on the list is to make it move, and for that,
a "click listener" is needed.

== Making it move ==

To receive a click event, FocusWidget.addClickListener() is to be used.
The widget itself will receive the mouse click event.  Open pyjamas/ui.py
and search for the function at FocusWidget.onBrowserEvent().  Examining
this function, it can be seen that a function called onClick() 
must be added to the VerticalDemoSlider class.  As we want to know <i>where</i>
the mouse was clicked, it is necessary to add two arguments to the onClick()
function, in order to receive the mouse event object as the second.
Add these additional lines to the ControlDemo class:
{{
        def onClick(self, sender, event):

            # work out the relative position of cursor
            mouse_y = DOM.eventGetClientY(event) - \
                       DOM.getAbsoluteTop(sender.getElement())
            self.moveSlider(mouse_y)

        def moveSlider(self, mouse_y):

            relative_y = mouse_y - DOM.getAbsoluteTop(self.getElement())
            widget_height = self.getOffsetHeight()

            # limit the position to be in the widget!
            if relative_y < 0:
                relative_y = 0
            height_range = widget_height - 10 # handle height is hard-coded
            if relative_y >= height_range:
                relative_y = height_range

            # move the handle
            DOM.setStyleAttribute(self.handle, "top", "%dpx" % relative_y)
            DOM.setStyleAttribute(self.handle, "position", "absolute")
}}
As can be seen, the mouse event y position is retrieved from the incoming
event; the absolute location of the container is subtracted, and this is
passed to <tt>moveSlider()</tt>.  In moveSlider, the "offset height" of the
widget is the total height of the widget, giving the travel range.
With a little math, the new position of the "handle" can be calculated,
in pixels. Again, learning from how AbsolutePanel sets the coordinates
of its child widgets, copying some lines of code from the function
AbsolutePanel.setWidgetPosition allows the location of the slider handle
to be set.

Save the changes to ControlDemo.py, re-build and refresh the browser.
Click on the slider, and... nothing should happen.  A very important
line was missed out!  Go back to VerticalDemoSlider.__init__ and add this,
at the end of the function, and try again:
{{
        self.addClickListener(self)
}}
Amazing!  a working slider widget!  A single-click moves the slider to
where you clicked the mouse.  Notice how the slider centre moves to where
your mouse pointer actually points to: this is entirely a fluke, and is
probably due to browser bugs in the CSS style implementation.
Notice also that we haven't actually set the value of the "slider", but
there's enough maths to calculate it.  We can add these extra lines
on to the end of moveSlider():
{{
        val_diff = self.max_value - self.min_value
        new_value = ((val_diff * relative_y) / height_range) + self.min_value
        self.setValue(new_value)
}}
Then, we also add a setValue() function, which not only records the
new value but also notifies any listeners.  Copying the style of
Label and other widgets' addClickListener() and removeClickListener()
functions, we're doing addControlValueListener() and
removeControlValueListener() to match.
{{
    def setValue(self, new_value):

        old_value = self.value
        self.value = new_value
        for listener in self.valuechange_listeners:
            listener.onControlValueChanged(self, old_value, new_value)

    def addControlValueListener(self, listener):
        self.valuechange_listeners.append(listener)

    def removeControlValueListener(self, listener):
        self.valuechange_listeners.remove(listener)

}}
Now we should really see if that works.  In the "test code",
add these extra lines to ControlDemo.onModuleLoad() and also
add the additional function onControlValueChanged:
{{
        b.addControlValueListener(self)
        self.label = Label("Not set yet")
        RootPanel().add(self.label)

    def onControlValueChanged(self, slider, old_value, new_value):
        self.label.setText("Value: %d" % int(new_value))
}}
A quick run of this shows our
<a href="./controls/output/ControlDemo.html">Control Demo app</a>
has a very boring
Text Label 200 pixels underneath a grey box, with the words
"Not set yet".  Clicking anywhere between the box and the words
not only moves the slider, but also changes the text to say
"Value: 83" or something to that effect.  Amazing.

== Improvements ==

Congratulations, you have a slider, in 70 lines of python code, and
a demonstration of its use in 20.  You can click on it.  Please
feel free to resist the urge to press the up and down arrows and
to click and hold the mouse: it won't work.  Adding that functionality
will be for another day's hacking, which you're welcome to send to
me (<a href="mailto:lkcl@lkcl.net">lkcl@lkcl.net</a>) and I will
add it in.

Hints: look at Image.onBrowserEvent() - you will notice that it
differs from FocusWidget.onBrowserEvent() in that it also handles
mouse move, enter, leave and up.  These events all get passed
to an instance of MouseListener(), calling its fireMouseEvent()
function.  Then, look at DialogBox and notice that it does all
sorts of strange and wonderful things, including the use of
"capture":
{{
    def onMouseDown(self, sender, x, y):
        self.dragging = True
        DOM.setCapture(self.caption.getElement())
        self.dragStartX = x
        self.dragStartY = y
}}
This is pretty important - to set "capture" of all mouse events.
In the case of the Dialog Box, the events are captured by the
"caption" at the top of the box, which is the "drag bar".  That
sounds... very much exactly like what we want, so feel free to
cut-and-paste DialogBox's onMouseDown, onMouseUp, onMouseMove,
onMouseLeave and onMouseEnter functions; remember to call
VerticalDemoSlider.moveSlider() not setPopupPosition(); and remember
to take a copy e.g. of Image.onBrowserEvent(), or take a copy
of FocusWidget.onBrowserEvent() and extend it with these all-important
lines:
{{
        elif type == "mouseup" or type == "mousemove" or type == "mouseover" or type == "mouseout":
            MouseListener().fireMouseEvent(self.mouseListeners, self, event)
}}
That should give you a slider which now accepts mouse drag-move
events, making it that little bit much more useful than one which
deals in single-clicks.  Once you've done that, of course, you might
want to remove the onClick() altogether, because of course a
single-click is also a mouse-down followed by a mouse-up event,
often, in many cases, accompanied by intermediate but very brief
mouse-move events.  The end-result will be doubling- or possibly
tripling- or more of value change notifications, all redundant,
and all wasting CPU cycles.

Once you've done <i>that</i>, you might also wish to improve the
widget further by detecting whether or not the mouse position was
<i>actually</i> changed.  Otherwise, you may end up with entirely
unnecessary calls to onControlValueChanged().  Don't be tempted to
short-cut the process by doing "if new_value != old_value", although
this is, strictly speaking, needed as well.  Record the old mouse
position on mouse-down, and only start sending onControlValueChanged()
notifications when the mouse "y" position differs from this recorded
value.
== Further enhancements and considerations ==

As part of a c++ widget set I helped develop and maintain in 1992
we had "ganging" sliders, which were for Stereo Volume control.
We created a "container" widget which allowed us to receive value
changes from an arbitrary number of "Control" widgets placed
within it.  The "difference" between the old and new values were
very important: we utilised these to make changes to the other
volume slider, allowing users to set the Left volume slightly
higher or lower than the Right volume, and then, on selecting the
"Ganging" switch, both volumes would waggle up and down by the
same amount, without mashing up to the same absolute value: an
undesirable oversight.

We had quite a lot of fun making test applications with half a dozen
sliders and dials, waggling one and watching the rest go bananas.
Given that this was running on 386sx 25mhz systems, it was also
quite impressive.  As it was a real-time (single-process!) application,
we had to pay particular attention to ensuring that the priority
was on getting the volume values to the DSP as fast as possible,
leaving visual changes as the absolute last priority-queued event.
Yes, we have a message-event system, like in Windows 3.1, except
we added "priority" to it, thus avoiding the need for threading
and still giving the application both responsiveness as well
as aural and visually accurate representation.

Any good "Control" widget system should keep these principles and
lessons in mind.

= Advanced Widgets = 

So, you read this tutorial: you went wow, big deal: my imagination
is now unlimited by the wondrous possibilities of being able to
manipulate the DOM model of a "page" - a screen - in a quick and
easy fashion.  However, my requirements are beyond what "DOM model"
can handle.  I want video.  I want 2D graphics.  I want 3D
graphics.  What do I do?

There are two answers.  The first one is: if your project requires
advanced 2D graphics manipulation, there is always the SVG Canvas, if
you have a web browser that can support SVG.  The Pyjamas "Canvas"
widget has been ported from the GWT Addons, and it works very well.
Pyjamas-Desktop does not at the moment support SVG, however it is
on the Roadmap.

Your second <i>really</i> "far out" option - given that the underlying
technology is web-browser-based - is to use Web Plugins.  For Safari,
Netscape, Firefox and WebKit (the last in the case of Pyjamas-Desktop),
you can write a plugin that conforms to the NPAPI standard, and
you're away.  I recommend that you start with the Adobe Flash plugin
source code.

But, before you go writing your own 3D, Video or other Multimedia
plugin, first check to see whether there is an existing NPAPI
or existing Web-based plugin that you can place into an iframe
or otherwise embed into a page.  Can you write the plugin in
Java, and run a Java applet in your page?  Can you use Adobe
Flash?  All of these possibilites are open to you, with no extra
particularly complex programming.
