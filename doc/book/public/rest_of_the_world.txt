= AJAX - Gateway to the World =

Javascript, when run in browsers, is restricted - for example,
access to user's files is off-limits.  So, even when running
Pyjamas-Desktop, your gateway to the rest of the world in Pyjamas
apps should be with AJAX - Asynchronous Javascript and XML.
The implications are that applications need to be divided
down into a front-end and a back-end, with the back-end running
on a Web Server.  Even for stand-alone applications, applications
still need to talk to a Web Server, which will need to be installed
locally.

Pyjamas includes a library - HTTPRequest - that provides convenient
access to AJAX.  The differences between Internet Explorer and other
browsers when using AJAX, that you'd normally be faced with, is taken care of
by the library, so that, on all platforms, the HTTPRequest library is
functionally identical.

The simplest use of HTTPRequest is to obtain text files or HTML
content from the server, whilst more involved ones will use HTTPRequest
to provide a Remote Procedure Call framework, such as JSONRPC or
XMLRPC.  Here are some Pyjamas examples, included with the Pyjamas
distribution, that use AJAX / HTTPRequest:
 * The slideshow example loads its slides in text format, and then applies some simple Wiki-like markup rules to convert the text file into HTML.
 * The TemplatePanel addons module can be used as the basis of a Content Manager, as it downloads HTML content, allows it to be edited (with FSCK Rich Text Editor) and uploaded - all using AJAX.
 * The JSONRPCService example shows how powerful AJAX can be, as the JSONRPC infrastructure transparently makes function calls look like they were being made on the server.

This latter example - the JSONRPCService one - is one which is going
to be explored in more detail, later, but first it's worth illustrating
with the simplest example, the Slideshow Loader.

= Simple use of HTTPRequest =

Here is the basis of the Slideshow example, which you should save as
Slideshow.py:
{{
from pyjamas.ui import HTML, RootPanel
from pyjamas.HTTPRequest import HTTPRequest

class SlideLoader:
    def __init__(self, panel):
        self.panel = panel

    def onCompletion(self, text):
        self.panel.setSlide(text)

    def onError(self, text, code):
        self.panel.onError(text, code)

    def onTimeout(self, text):
        self.panel.onTimeout(text)

class Slideshow:

    def onModuleLoad(self):
        self.slide = HTML()
        RootPanel.add(self.slide)

        HTTPRequest().asyncPost("test_slide.txt", "", SlideLoader(self))

    def setSlide(self, content):
        self.slide.setHTML("<pre>%s</pre>" % content
        
    def onError(self, text, code):
        self.slide.setHTML(text + "<br />" + code)
}}

Create a matching Slideshow.html, saving it in a folder called public:
{{
<html>
    <head>
        <meta name="pygwt:module" content="Slideshow">
        <title>Test Slideshow!</title>
    </head>
    <body bgcolor="white">
        <script language="javascript" src="pygwt.js"></script>

    <iframe id='__pygwt_historyFrame' style='width:0;height:0;border:0'></iframe>
    </body>
</html>
}}

Now create a test slide in the public folder, and call it test_slide.txt:
{{
Yippee, we get to see how AJAX works.
We put the content here, wrapped with <pre> </pre>
so it looks pretty.
You could put anything you wanted in here.
}}

You should now have three files on your computer like this:
{{
Slideshow.py
public/Slideshow.html
public/test_slide.txt
}}

Compile this example to javascript, by running the following command:
{{
   python ../../builder/build.py Slideshow.py
}}

You will now need to use a Web browser to access the output, but it is
important that you load the output from a Web Server, not from your local
filesystem.  There are several free web servers and web frameworks available,
and for the purposes of this exercise, one that serves static web pages is
perfectly adequate.

{{-info
AJAX has security restrictions on where the content can be downloaded from,
due to malicious misuse.  As there is no visual indication, with AJAX,
when content is being downloaded, AJAX was used to obtain and run malicious
scripts from web sites other than the one being presented to the user.
So, now, when you browse a web site, if AJAX is used, the AJAX content can
only be downloaded from the same web site.  Local file system URLs are
definitely "out".
}}

A recommended way to serve web pages is to install and use Apache2.
You should, after installation, set up a location where your compiled
output is made visible.  Here is an Apache Config snippet that you
can adapt to your needs, by changing the directory location:
{{
Alias /examples/ "/home/lkcl/src/pyjamas/examples/"
<Directory "/home/lkcl/src/pyjamas/examples/">
    Options +ExecCGI Indexes FollowSymLinks MultiViews
    AllowOverride None
    Order deny,allow
    allow from all
</Directory>
}}

The above is pretty standard fare for an Apache configuration: the only
additional thing that you might notice is that <tt>+ExecCGI</tt> has been
added, which will allow any executable applications to be run as CGI scripts
(such as EchoService.py for the JSONRPC example).  If you do not want
this feature, remove <tt>+ExecCGI</tt>.

{{-info
Remember to change the location to one where your output is compiled!
Also, make sure that you place the trailing slashes on the end of the
directory paths.  Also, remember to enable mod_cgi if you want CGI
scripts to run.
}}

With the above example, once you have started (or restarted) Apache2,
you will be able to open up a web browser on http://localhost/examples/
to run your application.  If successful, you should see the contents
of the test slide in the browser.

{{-info
Remember that if you don't see anything, check the Javascript console,
and enable script debugging.  Also, double-check that you have loaded
output/Slideshow.html, not public/Slideshow.html, in your browser.
}}

In the Pyjamas slideshow example, setSlide() munges the
AJAX-downloaded content before it gets displayed, and you could
prove to yourself that this is definitely not "static HTML" by
modifying the content in setSlide, by converting the content to
uppercase:
{{
    def setSlide(self, content):
        content = content.upper()
        self.slide.setHTML("<pre>%s</pre>") % content
}}

The extra line is the second one - modifying the content before it is
displayed.

{{-info
Remember to recompile the application, and refresh the browser.
}}

So, in this simple example, we've shown how to load content, dynamically.
Which is nice, because loading the Web page first, and the content separately,
is what AJAX is supposed to be all about: saving time and speeding up the
user experience.  Of course, loading only the one page isn't that much of
an improvement, but it's the thought that counts.  definitely.

However, with a small leap in imagination, it should be clear that
by specifying a dynamic URL in the HTTPRequest, instead of a static
page, this simple example could be adapted to load user's individual
email messages, or turned into a wiki.  The next step is to make the
process of loading those email messages, wiki pages or stock prices
that much easier, and that much more like a standard desktop application.

= JSONRPC: a better AJAX experience =

JSONRPC stands for "JavaScript Object Notation / Remote Procedure Calls".
To make sense of that banale sentence, it helps to look up the two
anacronyms separately.  JSON is simply a way to encode objects - lists,
dictionaries, integers, strings and floating point numbers - in a way
that web browsers will find easy to encode and decode.  RPC is simply
a way to make function calls on a server.  In other words, whilst the
function is being <i>called</i> on the client, the function is
<i>actually</i> executed on a (remote) server.

The best RPC systems allow the function's parameters to be shipped
back to the client, if they were modified, as well as the return
result of the function.  However, JSONRPC isn't the brightest bunny
on the block, and so we have to make do with just a return result.
Fortunately, JSON is capable of returning reasonably complex results -
lists of dictionaries, dictionaries of lists of strings etc. - so the
limitations of JSONRPC aren't the end of the world.

{{-info
The crucial difference between running an application that makes
"real" function calls rather than using a client-server arrangement
to proxy the function parameters and return result back-and-forth is
that, as a developer, you must <i>never</i> forget that the function
call can fail!  The server can, at any time, drop off the network,
or fail to respond in a timely fashion.  It's absolutely <i>essential</i>
that you design your application with this in mind.  RPC frameworks
help you out here, and the JSONRPC infrastructure in Pyjamas is no
exception.
}}

So, to get started with JSONRPC, the following is needed:
 * A JSONRPC client (there's one built in to Pyjamas)
 * A JSONRPC-aware Web Server Framework
 * A Web Server (even when running on the desktop)

Discussed first will be the frameworks: some of the Python-based
options, such as Twisted Matrix, Django, Web.py and cgi-bin will
be covered.  Next, once a framework is set up, connecting to it
with the JSONRPC example client will be covered.

= JSONRPC Web Server Frameworks =

There are dozens of JSONRPC frameworks available, as a quick google
search shows.  Any one of them will suffice, however the scope of this
book is limited to Python, so the following Python-based JSONRPC
frameworks will be covered:

 * Pimentech's libcommonDjango - JSON-RPC for Django.  libcommonDjango can be downloaded from http://lkcl.net/libcommonDjango.tgz and the Django Framework from http://djangoproject.com
 * Web.py, a minimalist powerful web framework, can also be used.  Download the JSONRPC example here: http://lkcl.net/webpy.jsonrpc.tgz and the Web.py Framework from http://webpy.org
 * CGI-based JSONRPC - there is an example already included in the Pyjamas distribution, examples/jsonrpc/public/services, called EchoService.py
 * txJSONRPC - JSON-RPC for Twisted.  txJSONRPC can be downloaded from https://launchpad.net/txjsonrpc and the Twisted Framework from http://twistedmatrix.com

So it is entirely up to you which one you use: the Pyjamas examples
even include a PHP-based JSONRPC service, using a php library called
phpolait.

== CGI-based JSONRPC ==

If you have a suitable web server installed, one of the simplest methods
to get started has to be CGI (Common Gateway Interface).  It's also one of
the slowest, causing the server to load an entire application just to serve
up one and only one web page - even if the response is a couple of lines,
which will often be the case on JSONRPC responses.

Examine the jsonrpc/public/services/EchoService.py source code - it's
pretty straightfoward:
{{
#!/usr/bin/env python

class Service:
    def echo(self, msg):
        return msg

    def reverse(self, msg):
        return msg[::-1]

    def uppercase(self, msg):
        return msg.upper()

    def lowercase(self, msg):
        return msg.lower()


from jsonrpc.cgihandler import handleCGIRequest

handleCGIRequest(Service())
}}

The first line tells a unix-based system that when this script is
executed, it must be executed as a python script.  Every individual
HTTP Request will result in a new process being started, to handle
the Request, and that process will terminate when the Response is
sent to the client.
{{-info
If running Windows, and Apache2 has been chosen as the web server, adding
<tt> AddHandler cgi-script .py </tt> to the Apache2 configuration section
will make all .py scripts in that section executable.  Only add this to
the sections that you need - don't add this Directive globally!
}}

The class "Service" contains our four functions that this JSONRPC service
will support.  Any JSONRPC client that has EchoService.py as its HTTP
"POST" url will be able to run these four functions.

The next two lines import and use handleCGIRequest to process the JSONRPC
query.  If you are interested, take a look in the public/services/jsonrpc
directory, at cgihandler.py - it's pretty straightforward, but it's just
a library.  The reason why it's mentioned is that you may be wondering
where jsonrpc.cgihandler comes from, when you haven't installed a library
called "jsonrpc" on your system: it's being imported from the <i>local</i>
path, by the python application, from the examples/public/services directory.

That's really all there is to it.  The dynamic capabilities of Python
allow the jsonrpc cgihandler library to match up the function call names
in the incoming HTTP POST with the function names in the Service() class
instance.  Adding extra functions is a trivial matter of adding new methods
to the Service class.

== JSONRPC in Django ==

This technique is a little more advanced, and relies on python "decorators",
so you will need to ensure that you at least have Python 2.4 or greater
(but not Python 3).  First, you should download and install both Django
and libcommonDjango, which are available from http://djangoproject.com
and http://lkcl.net/libcommonDjango.tgz respectively.

If you are unfamiliar with Django, then first, the standard Django Tutorial
should be followed.  By stage three, enough of a polls/view.py will have
been created such that the following lines can be added:
{{
from django.pimentech.network import JSONRPCService, jsonremote

testservice = JSONRPCService()

@jsonremote(testservice)
def echo(response, msg):
    try:
        poll_id = int(msg)
    except ValueError:
        return "You must type an integer, you typed: %s" % msg
    p = Poll.objects.get(pk=poll_id)
    return p.question

@jsonremote(testservice)
def reverse(response, msg):
    return msg[::-1]

@jsonremote(testservice)
def uppercase(response, msg):
    return msg.upper()

@jsonremote(testservice)
def lowercase(response, msg):
    return msg.lower()
}}

As can be seen, the libcommonDjango library from http://pimentech.com is
the key.  The <tt>@jsonremote()</tt> decorator turns the four functions
into JSONRPC server functions.  Note that, unlike the CGI-based example,
you have access to a <tt>response</tt> instance variable - just like in
any other Django HTTP Response processing function.

The <tt>echo</tt> function in this example reads from the Poll table,
just to demonstrate how interaction between JSONRPC and a database works.
If preferred, or the Django Tutorial is not being used, simply return msg
instead, to maintain consistency with the CGI-based example.

In Django, response-processing functions and classes don't magically get
called: it is necessary to map them to incoming HTTP urls using urls.py.
Edit the Django application's urls.py file, and add the line noted, below:
{{
urlpatterns = patterns('',
    # this is the JSONRPC service line that needs to be added:
    (r'^test-service/$', 'mysite.polls.views.testservice'),

    (r'^admin/(.*)', admin.site.root),
    (r'^polls/$', 'mysite.polls.views.index'),
}}

As can be seen, each line in urlpatterns maps a url to a class or function,
and in this example, if your web server is accessible at http://localhost
then any references to http://localhost/test-service/ will be mapped to
the JSONRPCService instance, testservice, in mysite/polls/views.py.

{{-info
Make sure that the urlpatterns match the application - in other words,
the example above is only valid if application is called "mysite".  Also,
take note of the URL, above, because it will be needed, later, when it comes
to connecting the JSONRPC-aware Pyjamas client to the Django server.
}}

When working with Django, any modifications that you make to the application
will be picked up automatically when running Django in "test" mode
(<tt>python manage.py 8080</tt>).  If running the application
using mod_python under Apache2, Apache2 will need to either be restarted
or reloaded.

{{-info
Apache2 is quite happy with a reload, if the application has no errors.
However, if an error occurs in the application, the thread will bomb out
and "stick".  As threads are chosen at random, to respond to requests,
what happens is that at some point in the future, the "stuck" thread will
be called on again to respond to a request... and it will respond with
<em>the same</em> error message, regardless of the request and regardless
of the requester.  So it is unfortunate but <em>vital</em> that you restart
Apache2 if an error occurs, when using mod_python.
}}

So, again - there's very little involved in setting up a JSONRPC service
under Django.  There's actually so little "hard work" that it's almost a
let-down to know that it <i>is</i> possible to do Web Development where
the technology doesn't get in the way.

== Web.py JSONRPC Server ==

Web.py is a very simple and straightforward web framework that is used
for some very substantial web sites.  The key significance of Web.py is
that it does not need to be run <i>from</i> a Web server, it <i>is</i> a
Web Server.

It's very simple to integrate JSONRPC into web.py.  First, download
and install web.py from http://webpy.org and also download a JSONRPC
library from http://lkcl.net/webpy.jsonrpc.tgz which contains a
modified version of Pimentech's JSONRPC service.  The modifications
are tiny but significant, allowing the raw data from the HTTP POST
to be passed to the JSONRPC Service.

Start by unpacking the archive, and creating a file with the following content.
The file should be saved in the directory where you have unpacked the archive,
so that the <tt>network</tt> library can be imported by it.
{{
#!/usr/bin/env python

from network import JSONRPCService, jsonremote
import web
import os

urls = (
    '/chat/', 'chatcls',
    '/chat',  'chatcls',
    )

# a "wrapper" class around the jsonrpc service "chatservice"
class chatcls:
    def POST(self):
        print chatservice(web.webapi.data())

chatservice = JSONRPCService()

# the two demo functions

@jsonremote(chatservice)
def echo(request, msg):
    web.debug(repr(request))
    return "hello world %s" % msg

@jsonremote(chatservice)
def reverse(request, msg):
    return "hello world %s" % msg[::-1]

@jsonremote(chatservice)
def uppercase(request, msg):
    return "hello world %s" % msg.upper()

@jsonremote(chatservice)
def lowercase(request, msg):
    return "hello world %s" % msg.lower()

# start me!
if __name__ == "__main__":
    web.run(urls, globals())
}}

Once again, we can see that it's really quite straightforward to set up
a JSONRPC Service.  In Web.py, the mapping between URLs and the handlers
is done in a similar fashion to Django (the urls variable); a key difference
between Django and Web.py is that classes must be used, and the classes
must have a GET (or in this case, a POST) function.  In this example,
a wrapper class has been used, that links the URL <tt>/chat/</tt> to the
JSONRPC service.

The last three lines run the built-in web server, which, by default,
will run on port 8000.  If the above code is saved as code.py, it
can be started with the command <tt>python code.py</tt>.  Starting
the application will allow the JSONRPC service to be accessed on
<tt>http://localhost:8000/chat/</tt> with a JSONRPC-aware client.
You will need to remember this URL when it comes to connecting the
client with the web.py server.

