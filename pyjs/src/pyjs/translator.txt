==========
Translator
==========

The python -> javascript translator translates a single module into a
javascript file. It accepts a list of source files, where each of the
files is an override of its predecessor.


    >>> from pyjs import translator

Let us write a simple module.

    >>> import tempfile, os
    >>> tmp = tempfile.mkdtemp()

    >>> mymodule1 = os.path.join(tmp, 'mymodule1.py')
    >>> out_file = os.path.join(tmp, 'mymodule.js')
    >>> f = file(mymodule1, 'w')
    >>> f.write("""
    ... def main():
    ...     print 1
    ... if __name__=='__main__':
    ...     main()
    ... """)
    >>> f.close()

The import statement just generates js functions, it does not care if
modules are there.

    >>> out_file = os.path.join(tmp, 'imports.js')
    >>> imports = os.path.join(tmp, 'imports.py')
    >>> f = file(imports, 'w')
    >>> f.write("""
    ... from x.z import y, p as pp
    ... import a.b
    ... a.b.something()
    ... import a
    ... a.something()
    ... a = 0
    ... a += 1
    ... bb = 0
    ... from a.b import c
    ... c()
    ... a = 42
    ... def main():
    ...      import a.b
    ...      a.b.something()
    ...      a = 1
    ...      import z as x
    ...      x()
    ...      from x.z import y, p as pp
    ... """)
    >>> f.close()

    >>> translator.translate([imports], out_file,
    ...                      debug=False,
    ...                      print_statements = True,
    ...                      function_argument_checking=True,
    ...                      attribute_checking=True,
    ...                      source_tracking=False,
    ...                      line_tracking=False,
    ...                      store_source=False)
    ['x.z.y', 'x', 'x.z', 'x.z.p', 'a.b', 'a', 'a.b.c', 'z']

    >>> print file(out_file).read()
    /* start module: imports */
    var imports = $pyjs.loaded_modules["imports"] = function (__mod_name__) {
    if(imports.__was_initialized__) return imports;
    imports.__was_initialized__ = true;
    if (__mod_name__ == null) __mod_name__ = 'imports';
    var __name__ = imports.__name__ = __mod_name__;
    try {
        pyjslib.__import__('x.z.y', 'imports')
        imports.y = sys.modules.x.z.y;
        pyjslib.__import__('x.z.p', 'imports')
        imports.pp = sys.modules.x.z.p;
        imports.a = pyjslib.__import__('a.b', 'imports')
        imports.a.b.something();
        imports.a = pyjslib.__import__('a', 'imports')
        imports.a.something();
        imports.a = 0;
        imports.a += 1;
        imports.bb = 0;
        imports.a = pyjslib.__import__('a.b.c', 'imports')
        imports.c = imports.a.b.c;
        imports.c();
        imports.a = 42;
        imports.main = function() {
                if ($pyjs.options.arg_count && arguments.length != 0) pyjs__exception_func_param(arguments.callee.__name__, 0, 0, arguments.length);
                var a = pyjslib.__import__('a.b', 'imports')
                a.b.something();
                a = 1;
                var x = pyjslib.__import__('z', 'imports')
                x();
                var x = pyjslib.__import__('x.z.y', 'imports')
                var y = x.z.y;
                var x = pyjslib.__import__('x.z.p', 'imports')
                var pp = x.z.p;
                return null;
        };
    ...
    /*
    PYJS_DEPS: ['x.z.y', 'x', 'x.z', 'x.z.p', 'a.b', 'a', 'a.b.c', 'z']
    */

    >>> baseclass = os.path.join(tmp, 'baseclass.py')
    >>> f = file(baseclass, 'w')
    >>> f.write("""
    ... if 1:
    ...     import pack4
    ... import pack1
    ... import pack1.mod
    ... import pack1.mod as jod
    ... from pack2.x import y
    ... from pack2.x import something as z
    ... print pack1
    ... print y
    ... def main():
    ...     import pack3
    ...     import pack3.sub
    ...     import pack3.sub as pub
    ...     from pack3 import z as y
    ...     print pack3
    ... """)
    >>> f.close()

    >>> deps = translator.translate([baseclass], out_file,
    ...                      debug=False,
    ...                      print_statements = True,
    ...                      function_argument_checking=True,
    ...                      attribute_checking=True,
    ...                      source_tracking=False,
    ...                      line_tracking=False,
    ...                      store_source=False)

Note that the __import__ function is called twice in edge-cases like
the on in this example, it does not matter because duplicate imports
do nothing. TODO: fix this

    >>> for line in file(out_file):
    ...     print line.strip()
    /* start module: baseclass */
    ...
    try {
    if (pyjslib.bool(1)) {
    baseclass.pack4 = pyjslib.__import__('pack4', 'baseclass')
    }
    baseclass.pack1 = pyjslib.__import__('pack1', 'baseclass')
    baseclass.pack1 = pyjslib.__import__('pack1.mod', 'baseclass')
    baseclass.jod = pyjslib.__import__('pack1.mod', 'baseclass')
    baseclass.pack2 = pyjslib.__import__('pack2.x.y', 'baseclass')
    baseclass.y = baseclass.pack2.x.y;
    baseclass.pack2 = pyjslib.__import__('pack2.x.something', 'baseclass')
    baseclass.z = baseclass.pack2.x.something;
    pyjslib.printFunc([baseclass.pack1], 1);
    pyjslib.printFunc([baseclass.y], 1);
    baseclass.main = function() {
    if ($pyjs.options.arg_count && arguments.length != 0) pyjs__exception_func_param(arguments.callee.__name__, 0, 0, arguments.length);
    var pack3 = pyjslib.__import__('pack3', 'baseclass')
    var pack3 = pyjslib.__import__('pack3.sub', 'baseclass')
    var pub = pyjslib.__import__('pack3.sub', 'baseclass')
    var pack3 = pyjslib.__import__('pack3.z', 'baseclass')
    var y = pack3.z;
    pyjslib.printFunc([pack3], 1);
    return null;
    };
    ...
    /*
    PYJS_DEPS: ['pack4', 'pack1', 'pack1.mod', 'pack2.x.y', 'pack2', 'pack2.x', 'pack2.x.something', 'pack3', 'pack3.sub', 'pack3.z']
    */

The following is nopt working right now.

    >>> more = os.path.join(tmp, 'more.py')
    >>> f = file(more, 'w')
    >>> f.write("""
    ... a = b = []
    ... 3 # works
    ... a[1] # is not working right now
    ... """)
    >>> f.close()

    >>> deps = translator.translate([more], out_file,
    ...                      debug=False,
    ...                      print_statements = True,
    ...                      function_argument_checking=True,
    ...                      attribute_checking=True,
    ...                      source_tracking=False,
    ...                      line_tracking=False,
    ...                      store_source=False)
    Traceback (most recent call last):
    ...
    TranslationError: more line 4:
    unsupported type, must be call or const (in _discard)
    Subscript(Name('a'), 'OP_APPLY', [Const(1)])

    >>> f = file(more, 'w')
    >>> f.write("""
    ... from write import write
    ... write()
    ... from write import x
    ... """)
    >>> f.close()

    >>> deps = translator.translate([more], out_file,
    ...                      debug=False,
    ...                      print_statements = True,
    ...                      function_argument_checking=True,
    ...                      attribute_checking=True,
    ...                      source_tracking=False,
    ...                      line_tracking=False,
    ...                      store_source=False)
    >>> for line in file(out_file):
    ...     print line.strip()

    >>> import shutil
    >>> shutil.rmtree(tmp)

